import { open } from "../deps/duckdb.ts";
import { Query } from "./query.ts";
import type { columnTypes } from "./types.d.ts";

/** DuckDB Loader configuration. */
interface DuckDbLoaderConfig {
  /** Database path. Defaults to ":memory:" */
  dbPath: string;
}

/** DuckDB Loader options - all parameters optional version of {@linkcode DuckDbLoaderConfig}. */
export type DuckDbLoaderOptions = Partial<DuckDbLoaderConfig>;

type DuckData = (
  ...params: columnTypes[]
) => Record<string, columnTypes>[];

export type Loader = (
  path: string,
) => Promise<DuckData>;

/**
 * Factory which generates a DuckDb loader.
 *
 * The loader generated by this factory loads SQL files from disk into
 * a {@linkcode Query} object. This is exposed in Lume as a function.
 *
 * @example Load SQL as DuckDB query
 * ```ts
 * site.loadData(['.sql'], duckLoader())
 * ```
 *
 * An SQL called `_data/simple.sql` file with the following content
 *
 * ```sql
 * select 1 as number;
 * ```
 *
 * Can be used in Lume pages as follows (assuming a Vento template).
 *
 * ```vento
 * {{ simple() |> JSON.stringify }}
 * ```
 *
 * @param options Configuration for factory
 * @returns DuckDB Loader
 */
export function duckDbLoader(options: DuckDbLoaderOptions = {}): Loader {
  const config: DuckDbLoaderConfig = {
    dbPath: ":memory:",
    ...options,
  };

  const db = _internals.open(config.dbPath);

  const loader = async (path: string) => {
    const query = new _internals.Query(db);
    await query.loadFile(path);
    const runner = (...params: columnTypes[]) => query.run(...params);
    runner.toString = () => {
      console.warn("DuckDB query called as string, not function.");
      return query.sql;
    };
    return runner;
  };

  return loader;
}

export const _internals = {
  open,
  Query,
};
